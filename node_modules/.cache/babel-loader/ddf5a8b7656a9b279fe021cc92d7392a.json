{"ast":null,"code":"/**\n * martinez v0.4.3\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.martinez = {});\n})(this, function (exports) {\n  'use strict';\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if (compare === void 0) compare = DEFAULT_COMPARE;\n    if (noDuplicates === void 0) noDuplicates = false;\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = {\n    size: {\n      configurable: true\n    }\n  };\n\n  SplayTree.prototype.rotateLeft = function rotateLeft(x) {\n    var y = x.right;\n\n    if (y) {\n      x.right = y.left;\n\n      if (y.left) {\n        y.left.parent = x;\n      }\n\n      y.parent = x.parent;\n    }\n\n    if (!x.parent) {\n      this._root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n\n    if (y) {\n      y.left = x;\n    }\n\n    x.parent = y;\n  };\n\n  SplayTree.prototype.rotateRight = function rotateRight(x) {\n    var y = x.left;\n\n    if (y) {\n      x.left = y.right;\n\n      if (y.right) {\n        y.right.parent = x;\n      }\n\n      y.parent = x.parent;\n    }\n\n    if (!x.parent) {\n      this._root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n\n    if (y) {\n      y.right = x;\n    }\n\n    x.parent = y;\n  };\n\n  SplayTree.prototype._splay = function _splay(x) {\n    var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n\n      if (!p.parent) {\n        if (p.left === x) {\n          this$1.rotateRight(p);\n        } else {\n          this$1.rotateLeft(p);\n        }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n  SplayTree.prototype.splay = function splay(x) {\n    var this$1 = this;\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n\n        if (ggp.left === gp) {\n          ggp.left = x;\n        } else {\n          ggp.right = x;\n        }\n\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left;\n      r = x.right;\n\n      if (x === p.left) {\n        // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else {\n              gp.left = null;\n            }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else {\n              gp.right = null;\n            }\n\n            x.left = gp;\n            gp.parent = x;\n          }\n        }\n\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else {\n          p.left = null;\n        }\n\n        x.right = p;\n        p.parent = x;\n      } else {\n        // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else {\n              gp.right = null;\n            }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else {\n              gp.left = null;\n            }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else {\n          p.right = null;\n        }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n  SplayTree.prototype.replace = function replace(u, v) {\n    if (!u.parent) {\n      this._root = v;\n    } else if (u === u.parent.left) {\n      u.parent.left = v;\n    } else {\n      u.parent.right = v;\n    }\n\n    if (v) {\n      v.parent = u.parent;\n    }\n  };\n\n  SplayTree.prototype.minNode = function minNode(u) {\n    if (u === void 0) u = this._root;\n\n    if (u) {\n      while (u.left) {\n        u = u.left;\n      }\n    }\n\n    return u;\n  };\n\n  SplayTree.prototype.maxNode = function maxNode(u) {\n    if (u === void 0) u = this._root;\n\n    if (u) {\n      while (u.right) {\n        u = u.right;\n      }\n    }\n\n    return u;\n  };\n\n  SplayTree.prototype.insert = function insert(key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n\n        if (cmp === 0) {\n          return;\n        } else if (comp(z.key, key) < 0) {\n          z = z.right;\n        } else {\n          z = z.left;\n        }\n      }\n    } else {\n      while (z) {\n        p = z;\n\n        if (comp(z.key, key) < 0) {\n          z = z.right;\n        } else {\n          z = z.left;\n        }\n      }\n    }\n\n    z = {\n      key: key,\n      data: data,\n      left: null,\n      right: null,\n      parent: p\n    };\n\n    if (!p) {\n      this._root = z;\n    } else if (comp(p.key, z.key) < 0) {\n      p.right = z;\n    } else {\n      p.left = z;\n    }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n  SplayTree.prototype.find = function find(key) {\n    var z = this._root;\n    var comp = this._compare;\n\n    while (z) {\n      var cmp = comp(z.key, key);\n\n      if (cmp < 0) {\n        z = z.right;\n      } else if (cmp > 0) {\n        z = z.left;\n      } else {\n        return z;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n\n\n  SplayTree.prototype.contains = function contains(key) {\n    var node = this._root;\n    var comparator = this._compare;\n\n    while (node) {\n      var cmp = comparator(key, node.key);\n\n      if (cmp === 0) {\n        return true;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        node = node.right;\n      }\n    }\n\n    return false;\n  };\n\n  SplayTree.prototype.remove = function remove(key) {\n    var z = this.find(key);\n\n    if (!z) {\n      return false;\n    }\n\n    this.splay(z);\n\n    if (!z.left) {\n      this.replace(z, z.right);\n    } else if (!z.right) {\n      this.replace(z, z.left);\n    } else {\n      var y = this.minNode(z.right);\n\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n  SplayTree.prototype.removeNode = function removeNode(z) {\n    if (!z) {\n      return false;\n    }\n\n    this.splay(z);\n\n    if (!z.left) {\n      this.replace(z, z.right);\n    } else if (!z.right) {\n      this.replace(z, z.left);\n    } else {\n      var y = this.minNode(z.right);\n\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n  SplayTree.prototype.erase = function erase(key) {\n    var z = this.find(key);\n\n    if (!z) {\n      return;\n    }\n\n    this.splay(z);\n    var s = z.left;\n    var t = z.right;\n    var sMax = null;\n\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n\n    if (t) {\n      if (s) {\n        sMax.right = t;\n      } else {\n        this._root = t;\n      }\n\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.pop = function pop() {\n    var node = this._root,\n        returnValue = null;\n\n    if (node) {\n      while (node.left) {\n        node = node.left;\n      }\n\n      returnValue = {\n        key: node.key,\n        data: node.data\n      };\n      this.remove(node.key);\n    }\n\n    return returnValue;\n  };\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.next = function next(node) {\n    var successor = node;\n\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n\n        while (successor && successor.left) {\n          successor = successor.left;\n        }\n      } else {\n        successor = node.parent;\n\n        while (successor && successor.right === node) {\n          node = successor;\n          successor = successor.parent;\n        }\n      }\n    }\n\n    return successor;\n  };\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.prev = function prev(node) {\n    var predecessor = node;\n\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n\n        while (predecessor && predecessor.right) {\n          predecessor = predecessor.right;\n        }\n      } else {\n        predecessor = node.parent;\n\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n\n\n  SplayTree.prototype.forEach = function forEach(callback) {\n    var current = this._root;\n    var s = [],\n        done = false,\n        i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++); // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n\n\n  SplayTree.prototype.range = function range(low, high, fn, ctx) {\n    var this$1 = this;\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root,\n        cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) {\n            return this$1;\n          } // stop if smth is returned\n\n        }\n\n        node = node.right;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n\n\n  SplayTree.prototype.keys = function keys() {\n    var current = this._root;\n    var s = [],\n        r = [],\n        done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return r;\n  };\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n\n\n  SplayTree.prototype.values = function values() {\n    var current = this._root;\n    var s = [],\n        r = [],\n        done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return r;\n  };\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.at = function at(index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n    var current = this._root;\n    var s = [],\n        done = false,\n        i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n\n          if (i === index) {\n            return current;\n          }\n\n          i++;\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n\n\n  SplayTree.prototype.load = function load(keys, values, presort) {\n    if (keys === void 0) keys = [];\n    if (values === void 0) values = [];\n    if (presort === void 0) presort = false;\n\n    if (this._size !== 0) {\n      throw new Error('bulk-load: tree is not empty');\n    }\n\n    var size = keys.length;\n\n    if (presort) {\n      sort(keys, values, 0, size - 1, this._compare);\n    }\n\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n  SplayTree.prototype.min = function min() {\n    var node = this.minNode(this._root);\n\n    if (node) {\n      return node.key;\n    } else {\n      return null;\n    }\n  };\n\n  SplayTree.prototype.max = function max() {\n    var node = this.maxNode(this._root);\n\n    if (node) {\n      return node.key;\n    } else {\n      return null;\n    }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty() {\n    return this._root === null;\n  };\n\n  prototypeAccessors.size.get = function () {\n    return this._size;\n  };\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n    * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n\n\n  SplayTree.createTree = function createTree(keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties(SplayTree.prototype, prototypeAccessors);\n\n  function loadRecursive(parent, keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = {\n        key: key,\n        data: data,\n        parent: parent\n      };\n      node.left = loadRecursive(node, keys, values, start, middle);\n      node.right = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) {\n      return;\n    }\n\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) {\n        break;\n      }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL = 0;\n  var NON_CONTRIBUTING = 1;\n  var SAME_TRANSITION = 2;\n  var DIFFERENT_TRANSITION = 3;\n  var INTERSECTION = 0;\n  var UNION = 1;\n  var DIFFERENCE = 2;\n  var XOR = 3;\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n\n  function computeFields(event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut = false;\n      event.otherInOut = true; // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut = !prev.inOut;\n        event.otherInOut = prev.otherInOut; // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      } // compute prevInResult field\n\n\n      if (prev) {\n        event.prevInResult = !inResult(prev, operation) || prev.isVertical() ? prev.prevInResult : prev;\n      }\n    } // check if the line segment belongs to the Boolean operation\n\n\n    event.inResult = inResult(event, operation);\n  }\n  /* eslint-disable indent */\n\n\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n\n          case UNION:\n            return event.otherInOut;\n\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return event.isSubject && event.otherInOut || !event.isSubject && !event.otherInOut;\n\n          case XOR:\n            return true;\n        }\n\n        break;\n\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n\n      case NON_CONTRIBUTING:\n        return false;\n    }\n\n    return false;\n  }\n  /* eslint-enable indent */\n\n\n  var SweepEvent = function SweepEvent(point, left, otherEvent, isSubject, edgeType) {\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n    /**\n     * @type {Array.<Number>}\n     */\n\n    this.point = point;\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n\n    this.otherEvent = otherEvent;\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n\n    this.isSubject = isSubject;\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n\n    this.type = edgeType || NORMAL;\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n\n    this.inOut = false;\n    /**\n     * @type {Boolean}\n     */\n\n    this.otherInOut = false;\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n\n    this.prevInResult = null;\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n\n    this.inResult = false; // connection step\n\n    /**\n     * @type {Boolean}\n     */\n\n    this.resultInOut = false;\n    this.isExteriorRing = true;\n  };\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n\n\n  SweepEvent.prototype.isBelow = function isBelow(p) {\n    var p0 = this.point,\n        p1 = this.otherEvent.point;\n    return this.left ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0 // signedArea(this.point, this.otherEvent.point, p) > 0 :\n    : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0; //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n\n\n  SweepEvent.prototype.isAbove = function isAbove(p) {\n    return !this.isBelow(p);\n  };\n  /**\n   * @return {Boolean}\n   */\n\n\n  SweepEvent.prototype.isVertical = function isVertical() {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n  SweepEvent.prototype.clone = function clone() {\n    var copy = new SweepEvent(this.point, this.left, this.otherEvent, this.isSubject, this.type);\n    copy.inResult = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut = this.inOut;\n    copy.otherInOut = this.otherInOut;\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    return false;\n  } // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n\n\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n\n\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point; // Different x-coordinate\n\n    if (p1[0] > p2[0]) {\n      return 1;\n    }\n\n    if (p1[0] < p2[0]) {\n      return -1;\n    } // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n\n\n    if (p1[1] !== p2[1]) {\n      return p1[1] > p2[1] ? 1 : -1;\n    }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n  /* eslint-disable no-unused-vars */\n\n\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left) {\n      return e1.left ? 1 : -1;\n    } // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n\n\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return !e1.isBelow(e2.otherEvent.point) ? 1 : -1;\n    }\n\n    return !e1.isSubject && e2.isSubject ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n\n\n  function divideSegment(se, p, queue) {\n    var r = new SweepEvent(p, false, se, se.isSubject);\n    var l = new SweepEvent(p, true, se.otherEvent, se.isSubject);\n    /* eslint-disable no-console */\n\n    if (equals(se.point, se.otherEvent.point)) {\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n\n    r.contourId = l.contourId = se.contourId; // avoid a rounding error. The left event would be processed after the right event\n\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    } // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n    queue.push(l);\n    queue.push(r);\n    return queue;\n  } //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n\n\n  function crossProduct(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n  }\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n\n\n  function dotProduct(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n\n\n  function intersection(a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]]; // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [p[0] + s * d[0], p[1] + s * d[1]];\n    }\n    /* eslint-enable arrow-body-style */\n    // The rest is pretty much a straight port of the algorithm.\n\n\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA = dotProduct(va, va); //const sqrLenB  = dotProduct(vb, vb);\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n\n    if (sqrKross > 0\n    /* EPS * sqrLenB * sqLenA */\n    ) {\n        // If they're not parallel, then (because these are line segments) they\n        // still might not actually intersect. This code checks that the\n        // intersection point of the lines is actually on both line segments.\n        var s = crossProduct(e, vb) / kross;\n\n        if (s < 0 || s > 1) {\n          // not on line segment a\n          return null;\n        }\n\n        var t = crossProduct(e, va) / kross;\n\n        if (t < 0 || t > 1) {\n          // not on line segment b\n          return null;\n        }\n\n        if (s === 0 || s === 1) {\n          // on an endpoint of line segment a\n          return noEndpointTouch ? null : [toPoint(a1, s, va)];\n        }\n\n        if (t === 0 || t === 1) {\n          // on an endpoint of line segment b\n          return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n        }\n\n        return [toPoint(a1, s, va)];\n      } // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n\n\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0\n    /* EPS * sqLenB * sqLenE */\n    ) {\n        // Lines are just parallel, not the same. No overlap.\n        return null;\n      }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb); // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n\n    if (smin <= 1 && smax >= 0) {\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) {\n        return null;\n      } // There's overlap on a segment -- two points of intersection. Return both.\n\n\n      return [toPoint(a1, smin > 0 ? smin : 0, va), toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    return null;\n  }\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n\n\n  function possibleIntersection(se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    var nintersections = inter ? inter.length : 0;\n\n    if (nintersections === 0) {\n      return 0;\n    } // no intersection\n    // the line segments intersect at an endpoint of both line segments\n\n\n    if (nintersections === 1 && (equals(se1.point, se2.point) || equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    } // The line segments associated to se1 and se2 intersect\n\n\n    if (nintersections === 1) {\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      } // if the intersection point is not an endpoint of se2\n\n\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n\n      return 1;\n    } // The line segments associated to se1 and se2 overlap\n\n\n    var events = [];\n    var leftCoincide = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if (leftCoincide && rightCoincide || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = se2.inOut === se1.inOut ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n\n      return 2;\n    } // the line segments share the right endpoint\n\n\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    } // no line segment includes totally the other one\n\n\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    } // one line segment includes the other one\n\n\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n    return 3;\n  }\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n\n\n  function compareSegments(le1, le2) {\n    if (le1 === le2) {\n      return 0;\n    } // Segments are not collinear\n\n\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 || signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) {\n        return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n      } // Different left endpoint: use the left endpoint to sort\n\n\n      if (le1.point[0] === le2.point[0]) {\n        return le1.point[1] < le2.point[1] ? -1 : 1;\n      } // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n\n\n      if (compareEvents(le1, le2) === 1) {\n        return le2.isAbove(le1.point) ? -1 : 1;\n      } // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n\n\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) {\n      // same polygon\n      var p1 = le1.point,\n          p2 = le2.point;\n\n      if (p1[0] === p2[0] && p1[1] === p2[1]\n      /*equals(le1.point, le2.point)*/\n      ) {\n          p1 = le1.otherEvent.point;\n          p2 = le2.otherEvent.point;\n\n          if (p1[0] === p2[0] && p1[1] === p2[1]) {\n            return 0;\n          } else {\n            return le1.contourId > le2.contourId ? 1 : -1;\n          }\n        }\n    } else {\n      // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event); // optimization by bboxes for intersection and difference goes here\n\n      if (operation === INTERSECTION && event.point[0] > rightbound || operation === DIFFERENCE && event.point[0] > sbbox[2]) {\n        break;\n      }\n\n      if (event.left) {\n        next = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) {\n          prev = sweepLine.prev(prev);\n        } else {\n          prev = null;\n        }\n\n        next = sweepLine.next(next);\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = void 0;\n        computeFields(event, prevEvent, operation);\n\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n\n            if (prevprev !== begin) {\n              prevprev = sweepLine.prev(prevprev);\n            } else {\n              prevprev = null;\n            }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event, prevEvent, operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n          if (prev !== begin) {\n            prev = sweepLine.prev(prev);\n          } else {\n            prev = null;\n          }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n\n    return sortedEvents;\n  }\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n\n\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n\n      if (event.left && event.inResult || !event.left && event.otherEvent.inResult) {\n        resultEvents.push(event);\n      }\n    } // Due to overlapping edges the resultEvents array can be not wholly sorted\n\n\n    var sorted = false;\n\n    while (!sorted) {\n      sorted = true;\n\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if (i + 1 < len && compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    } // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n\n\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n\n    if (newPos > length - 1) {\n      return pos - 1;\n    }\n\n    var p = resultEvents[pos].point;\n    var p1 = resultEvents[newPos].point; // while in range and not the current one by value\n\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else {\n        newPos++;\n      }\n\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n\n    return newPos;\n  }\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n\n\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents); // \"false\"-filled array\n\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) {\n        continue;\n      }\n\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId = ringId;\n    } // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n\n\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n    var this$1 = this;\n\n    if (!(this instanceof TinyQueue)) {\n      return new TinyQueue(data, compare);\n    }\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n      for (var i = (this.length >> 1) - 1; i >= 0; i--) {\n        this$1._down(i);\n      }\n    }\n  }\n\n  function defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n    push: function (item) {\n      this.data.push(item);\n      this.length++;\n\n      this._up(this.length - 1);\n    },\n    pop: function () {\n      if (this.length === 0) {\n        return undefined;\n      }\n\n      var top = this.data[0];\n      this.length--;\n\n      if (this.length > 0) {\n        this.data[0] = this.data[this.length];\n\n        this._down(0);\n      }\n\n      this.data.pop();\n      return top;\n    },\n    peek: function () {\n      return this.data[0];\n    },\n    _up: function (pos) {\n      var data = this.data;\n      var compare = this.compare;\n      var item = data[pos];\n\n      while (pos > 0) {\n        var parent = pos - 1 >> 1;\n        var current = data[parent];\n\n        if (compare(item, current) >= 0) {\n          break;\n        }\n\n        data[pos] = current;\n        pos = parent;\n      }\n\n      data[pos] = item;\n    },\n    _down: function (pos) {\n      var this$1 = this;\n      var data = this.data;\n      var compare = this.compare;\n      var halfLength = this.length >> 1;\n      var item = data[pos];\n\n      while (pos < halfLength) {\n        var left = (pos << 1) + 1;\n        var right = left + 1;\n        var best = data[left];\n\n        if (right < this$1.length && compare(data[right], best) < 0) {\n          left = right;\n          best = data[right];\n        }\n\n        if (compare(best, item) >= 0) {\n          break;\n        }\n\n        data[pos] = best;\n        pos = left;\n      }\n\n      data[pos] = item;\n    }\n  };\n  tinyqueue.default = default_1;\n  var max = Math.max;\n  var min = Math.min;\n  var contourId = 0;\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1, isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0],\n          y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y); // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n\n        if (isExteriorRing) {\n          contourId++;\n        }\n\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n\n        if (operation === DIFFERENCE) {\n          isExteriorRing = false;\n        }\n\n        if (isExteriorRing) {\n          contourId++;\n        }\n\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n\n    if (subject.length * clipping.length === 0) {\n      if (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION || operation === XOR) {\n        result = subject.length === 0 ? clipping : subject;\n      }\n    }\n\n    return result;\n  }\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n\n    if (sbbox[0] > cbbox[2] || cbbox[0] > sbbox[2] || sbbox[1] > cbbox[3] || cbbox[1] > sbbox[3]) {\n      if (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION || operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n\n    return result;\n  }\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n\n    var trivial = trivialOperation(subject, clipping, operation);\n\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity]; //console.time('fill queue');\n\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation); //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    } //console.time('subdivide edges');\n\n\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation); //console.timeEnd('subdivide edges');\n    //console.time('connect vertices');\n\n    var result = connectEdges(sortedEvents, operation); //console.timeEnd('connect vertices');\n\n    return result;\n  }\n\n  function union(subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff(subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor(subject, clipping) {\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1(subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n  /**\n   * @enum {Number}\n   */\n\n\n  var operations = {\n    UNION: UNION,\n    DIFFERENCE: DIFFERENCE,\n    INTERSECTION: INTERSECTION,\n    XOR: XOR\n  };\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../node_modules/splaytree/index.js","../src/edge_type.js","../src/operation.js","../src/compute_fields.js","../src/sweep_event.js","../src/equals.js","../src/signed_area.js","../src/compare_events.js","../src/divide_segment.js","../src/segment_intersection.js","../src/possible_intersection.js","../src/compare_segments.js","../src/subdivide_segments.js","../src/connect_edges.js","../node_modules/tinyqueue/index.js","../src/fill_queue.js","../src/index.js","../index.js"],"names":["this","const","let","Tree","Queue","subdivideSegments","intersection"],"mappings":"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","sourcesContent":["function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\nexport default class SplayTree {\n\n  constructor(compare = DEFAULT_COMPARE, noDuplicates = false) {\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  }\n\n\n  rotateLeft(x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) y.left.parent = x;\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)                this._root = y;\n    else if (x === x.parent.left) x.parent.left = y;\n    else                          x.parent.right = y;\n    if (y) y.left = x;\n    x.parent = y;\n  }\n\n\n  rotateRight(x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) y.right.parent = x;\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)               this._root = y;\n    else if(x === x.parent.left) x.parent.left = y;\n    else                         x.parent.right = y;\n    if (y) y.right = x;\n    x.parent = y;\n  }\n\n\n  _splay(x) {\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) this.rotateRight(p);\n        else              this.rotateLeft(p);\n      } else if (p.left === x && p.parent.left === p) {\n        this.rotateRight(p.parent);\n        this.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this.rotateLeft(p.parent);\n        this.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this.rotateRight(p);\n        this.rotateLeft(p);\n      } else {\n        this.rotateLeft(p);\n        this.rotateRight(p);\n      }\n    }\n  }\n\n\n  splay(x) {\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) ggp.left  = x;\n        else                 ggp.right = x;\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else gp.left = null;\n\n            p.right   = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else gp.right = null;\n\n            x.left    = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else p.left = null;\n\n        x.right  = p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else gp.right = null;\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else gp.left = null;\n\n            x.right   = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else p.right = null;\n\n        x.left   = p;\n        p.parent = x;\n      }\n    }\n  }\n\n\n  replace(u, v) {\n    if (!u.parent) this._root = v;\n    else if (u === u.parent.left) u.parent.left = v;\n    else u.parent.right = v;\n    if (v) v.parent = u.parent;\n  }\n\n\n  minNode(u = this._root) {\n    if (u) while (u.left) u = u.left;\n    return u;\n  }\n\n\n  maxNode(u = this._root) {\n    if (u) while (u.right) u = u.right;\n    return u;\n  }\n\n\n  insert(key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) return;\n        else if (comp(z.key, key) < 0) z = z.right;\n        else z = z.left;\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) z = z.right;\n        else z = z.left;\n      }\n    }\n\n    z = { key, data, left: null, right: null, parent: p };\n\n    if (!p)                          this._root = z;\n    else if (comp(p.key, z.key) < 0) p.right = z;\n    else                             p.left  = z;\n\n    this.splay(z);\n    this._size++;\n    return z;\n  }\n\n\n  find (key) {\n    var z    = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if      (cmp < 0) z = z.right;\n      else if (cmp > 0) z = z.left;\n      else              return z;\n    }\n    return null;\n  }\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param  {Key} key\n   * @return {boolean} true/false\n   */\n  contains (key) {\n    var node       = this._root;\n    var comparator = this._compare;\n    while (node)  {\n      var cmp = comparator(key, node.key);\n      if      (cmp === 0) return true;\n      else if (cmp < 0)   node = node.left;\n      else                node = node.right;\n    }\n\n    return false;\n  }\n\n\n  remove (key) {\n    var z = this.find(key);\n\n    if (!z) return false;\n\n    this.splay(z);\n\n    if (!z.left) this.replace(z, z.right);\n    else if (!z.right) this.replace(z, z.left);\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  }\n\n\n  removeNode(z) {\n    if (!z) return false;\n\n    this.splay(z);\n\n    if (!z.left) this.replace(z, z.right);\n    else if (!z.right) this.replace(z, z.left);\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  }\n\n\n  erase (key) {\n    var z = this.find(key);\n    if (!z) return;\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) sMax.right = t;\n      else   this._root = t;\n      t.parent = sMax;\n    }\n\n    this._size--;\n  }\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) node = node.left;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) successor = successor.left;\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  }\n\n\n  /**\n   * Predecessor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) predecessor = predecessor.right;\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  }\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param  {forEachCallback} callback\n   * @return {SplayTree}\n   */\n  forEach(callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range(low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._compare;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param  {Array<Key>}    keys\n   * @param  {Array<Value>}  [values]\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n   *                                         tree's comparator. Sorting is done\n   *                                         in-place\n   * @return {AVLTree}\n   */\n  load(keys = [], values = [], presort = false) {\n    if (this._size !== 0) throw new Error('bulk-load: tree is not empty');\n    const size = keys.length;\n    if (presort) sort(keys, values, 0, size - 1, this._compare);\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  }\n\n\n  min() {\n    var node = this.minNode(this._root);\n    if (node) return node.key;\n    else      return null;\n  }\n\n\n  max() {\n    var node = this.maxNode(this._root);\n    if (node) return node.key;\n    else      return null;\n  }\n\n  isEmpty() { return this._root === null; }\n  get size() { return this._size; }\n\n\n  /**\n   * Create a tree and load it with items\n   * @param  {Array<Key>}          keys\n   * @param  {Array<Value>?}        [values]\n\n   * @param  {Function?}            [comparator]\n   * @param  {Boolean?}             [presort=false] Pre-sort keys and values, using\n   *                                               tree's comparator. Sorting is done\n   *                                               in-place\n   * @param  {Boolean?}             [noDuplicates=false]   Allow duplicates\n   * @return {SplayTree}\n   */\n  static createTree(keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  }\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","export const NORMAL               = 0;\nexport const NON_CONTRIBUTING     = 1;\nexport const SAME_TRANSITION      = 2;\nexport const DIFFERENT_TRANSITION = 3;\n","export const INTERSECTION = 0;\nexport const UNION        = 1;\nexport const DIFFERENCE   = 2;\nexport const XOR          = 3;\n","import {\n  NORMAL,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION,\n  NON_CONTRIBUTING\n} from './edge_type';\nimport {\n  INTERSECTION,\n  UNION,\n  DIFFERENCE,\n  XOR\n} from './operation';\n\n/**\n * @param  {SweepEvent} event\n * @param  {SweepEvent} prev\n * @param  {Operation} operation\n */\nexport default function computeFields (event, prev, operation) {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else {\n    if (event.isSubject === prev.isSubject) {\n      event.inOut      = !prev.inOut;\n      event.otherInOut = prev.otherInOut;\n\n    // previous line segment in sweepline belongs to the clipping polygon\n    } else {\n      event.inOut      = !prev.otherInOut;\n      event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n    }\n\n    // compute prevInResult field\n    if (prev) {\n      event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n        ? prev.prevInResult : prev;\n    }\n  }\n\n  // check if the line segment belongs to the Boolean operation\n  event.inResult = inResult(event, operation);\n}\n\n\n/* eslint-disable indent */\nfunction inResult(event, operation) {\n  switch (event.type) {\n    case NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          // return (event.isSubject && !event.otherInOut) ||\n          //         (!event.isSubject && event.otherInOut);\n          return (event.isSubject && event.otherInOut) ||\n                  (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n      break;\n    case SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}\n/* eslint-enable indent */\n","import { NORMAL } from './edge_type';\n\n\nexport default class SweepEvent {\n\n\n  /**\n   * Sweepline event\n   *\n   * @class {SweepEvent}\n   * @param {Array.<Number>}  point\n   * @param {Boolean}         left\n   * @param {SweepEvent=}     otherEvent\n   * @param {Boolean}         isSubject\n   * @param {Number}          edgeType\n   */\n  constructor (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n    this.inResult = false;\n\n\n    // connection step\n\n    /**\n     * @type {Boolean}\n     */\n    this.resultInOut = false;\n\n    this.isExteriorRing = true;\n  }\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isBelow (p) {\n    const p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  }\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isAbove (p) {\n    return !this.isBelow(p);\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  }\n\n\n  clone () {\n    const copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult       = this.inResult;\n    copy.prevInResult   = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut          = this.inOut;\n    copy.otherInOut     = this.otherInOut;\n\n    return copy;\n  }\n}\n","export default function equals(p1, p2) {\n  if (p1[0] === p2[0]) {\n    if (p1[1] === p2[1]) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n// const EPSILON = 1e-9;\n// const abs = Math.abs;\n// TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n// Precision problem.\n//\n// module.exports = function equals(p1, p2) {\n//   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n// };\n","/**\n * Signed area of the triangle (p0, p1, p2)\n * @param  {Array.<Number>} p0\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Number}\n */\nexport default function signedArea(p0, p1, p2) {\n  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n}\n","import signedArea from './signed_area';\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nexport default function compareEvents(e1, e2) {\n  const p1 = e1.point;\n  const p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  return specialCases(e1, e2, p1, p2);\n}\n\n\n/* eslint-disable no-unused-vars */\nfunction specialCases(e1, e2, p1, p2) {\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n  // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n/* eslint-enable no-unused-vars */\n","import SweepEvent    from './sweep_event';\nimport equals        from './equals';\nimport compareEvents from './compare_events';\n\n/**\n * @param  {SweepEvent} se\n * @param  {Array.<Number>} p\n * @param  {Queue} queue\n * @return {Queue}\n */\nexport default function divideSegment(se, p, queue)  {\n  const r = new SweepEvent(p, false, se,            se.isSubject);\n  const l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  /* eslint-disable no-console */\n  if (equals(se.point, se.otherEvent.point)) {\n\n    console.warn('what is that, a collapsed segment?', se);\n  }\n  /* eslint-enable no-console */\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n}\n","//const EPS = 1e-9;\n\n/**\n * Finds the magnitude of the cross product of two vectors (if we pretend\n * they're in three dimensions)\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The magnitude of the cross product\n */\nfunction crossProduct(a, b) {\n  return (a[0] * b[1]) - (a[1] * b[0]);\n}\n\n/**\n * Finds the dot product of two vectors.\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The dot product\n */\nfunction dotProduct(a, b) {\n  return (a[0] * b[0]) + (a[1] * b[1]);\n}\n\n/**\n * Finds the intersection (if any) between two line segments a and b, given the\n * line segments' end points a1, a2 and b1, b2.\n *\n * This algorithm is based on Schneider and Eberly.\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n * Page 244.\n *\n * @param {Array.<Number>} a1 point of first line\n * @param {Array.<Number>} a2 point of first line\n * @param {Array.<Number>} b1 point of second line\n * @param {Array.<Number>} b2 point of second line\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n *                                         (meaning connected segments) as\n *                                         intersections\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n * intersection. If they overlap, the two end points of the overlapping segment.\n * Otherwise, null.\n */\nexport default function (a1, a2, b1, b2, noEndpointTouch) {\n  // The algorithm expects our lines in the form P + sd, where P is a point,\n  // s is on the interval [0, 1], and d is a vector.\n  // We are passed two points. P can be the first point of each pair. The\n  // vector, then, could be thought of as the distance (in x and y components)\n  // from the first point to the second point.\n  // So first, let's make our vectors:\n  const va = [a2[0] - a1[0], a2[1] - a1[1]];\n  const vb = [b2[0] - b1[0], b2[1] - b1[1]];\n  // We also define a function to convert back to regular point form:\n\n  /* eslint-disable arrow-body-style */\n\n  function toPoint(p, s, d) {\n    return [\n      p[0] + s * d[0],\n      p[1] + s * d[1]\n    ];\n  }\n\n  /* eslint-enable arrow-body-style */\n\n  // The rest is pretty much a straight port of the algorithm.\n  const e = [b1[0] - a1[0], b1[1] - a1[1]];\n  let kross    = crossProduct(va, vb);\n  let sqrKross = kross * kross;\n  const sqrLenA  = dotProduct(va, va);\n  //const sqrLenB  = dotProduct(vb, vb);\n\n  // Check for line intersection. This works because of the properties of the\n  // cross product -- specifically, two vectors are parallel if and only if the\n  // cross product is the 0 vector. The full calculation involves relative error\n  // to account for possible very small line segments. See Schneider & Eberly\n  // for details.\n  if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n    // If they're not parallel, then (because these are line segments) they\n    // still might not actually intersect. This code checks that the\n    // intersection point of the lines is actually on both line segments.\n    const s = crossProduct(e, vb) / kross;\n    if (s < 0 || s > 1) {\n      // not on line segment a\n      return null;\n    }\n    const t = crossProduct(e, va) / kross;\n    if (t < 0 || t > 1) {\n      // not on line segment b\n      return null;\n    }\n    if (s === 0 || s === 1) {\n      // on an endpoint of line segment a\n      return noEndpointTouch ? null : [toPoint(a1, s, va)];\n    }\n    if (t === 0 || t === 1) {\n      // on an endpoint of line segment b\n      return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n    }\n    return [toPoint(a1, s, va)];\n  }\n\n  // If we've reached this point, then the lines are either parallel or the\n  // same, but the segments could overlap partially or fully, or not at all.\n  // So we need to find the overlap, if any. To do that, we can use e, which is\n  // the (vector) difference between the two initial points. If this is parallel\n  // with the line itself, then the two lines are the same line, and there will\n  // be overlap.\n  //const sqrLenE = dotProduct(e, e);\n  kross = crossProduct(e, va);\n  sqrKross = kross * kross;\n\n  if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n  // Lines are just parallel, not the same. No overlap.\n    return null;\n  }\n\n  const sa = dotProduct(va, e) / sqrLenA;\n  const sb = sa + dotProduct(va, vb) / sqrLenA;\n  const smin = Math.min(sa, sb);\n  const smax = Math.max(sa, sb);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n\n    // overlap on an end point\n    if (smin === 1) {\n      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n    }\n\n    if (smax === 0) {\n      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    if (noEndpointTouch && smin === 0 && smax === 1) return null;\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    return [\n      toPoint(a1, smin > 0 ? smin : 0, va),\n      toPoint(a1, smax < 1 ? smax : 1, va)\n    ];\n  }\n\n  return null;\n}\n","import divideSegment from './divide_segment';\nimport intersection  from './segment_intersection';\nimport equals        from './equals';\nimport compareEvents from './compare_events';\nimport {\n  NON_CONTRIBUTING,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION\n} from './edge_type';\n\n/**\n * @param  {SweepEvent} se1\n * @param  {SweepEvent} se2\n * @param  {Queue}      queue\n * @return {Number}\n */\nexport default function possibleIntersection (se1, se2, queue) {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n  const inter = intersection(\n    se1.point, se1.otherEvent.point,\n    se2.point, se2.otherEvent.point\n  );\n\n  const nintersections = inter ? inter.length : 0;\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n    // if(se1.contourId === se2.contourId){\n    // console.warn('Edges of the same polygon overlap',\n    //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    // }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n      divideSegment(se1, inter[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n      divideSegment(se2, inter[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  const events        = [];\n  let leftCoincide  = false;\n  let rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se2.type = NON_CONTRIBUTING;\n    se1.type = (se2.inOut === se1.inOut)\n      ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[1].otherEvent, events[0].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n}\n","import signedArea    from './signed_area';\nimport compareEvents from './compare_events';\nimport equals        from './equals';\n\n\n/**\n * @param  {SweepEvent} le1\n * @param  {SweepEvent} le2\n * @return {Number}\n */\nexport default function compareSegments(le1, le2) {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return le1.isBelow(le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    let p1 = le1.point, p2 = le2.point;\n    if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n      p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]) return 0;\n      else return le1.contourId > le2.contourId ? 1 : -1;\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n}\n","import Tree                 from 'splaytree';\nimport computeFields        from './compute_fields';\nimport possibleIntersection from './possible_intersection';\nimport compareSegments      from './compare_segments';\nimport {\n  INTERSECTION,\n  DIFFERENCE\n} from './operation';\n\n\nexport default function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n  const sweepLine = new Tree(compareSegments);\n  const sortedEvents = [];\n\n  const rightbound = Math.min(sbbox[2], cbbox[2]);\n\n  let prev, next, begin;\n\n  while (eventQueue.length !== 0) {\n    let event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      next  = prev = sweepLine.insert(event);\n      begin = sweepLine.minNode();\n\n      if (prev !== begin) prev = sweepLine.prev(prev);\n      else                prev = null;\n\n      next = sweepLine.next(next);\n\n      const prevEvent = prev ? prev.key : null;\n      let prevprevEvent;\n      computeFields(event, prevEvent, operation);\n      if (next) {\n        if (possibleIntersection(event, next.key, eventQueue) === 2) {\n          computeFields(event, prevEvent, operation);\n          computeFields(event, next.key, operation);\n        }\n      }\n\n      if (prev) {\n        if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n          let prevprev = prev;\n          if (prevprev !== begin) prevprev = sweepLine.prev(prevprev);\n          else                    prevprev = null;\n\n          prevprevEvent = prevprev ? prevprev.key : null;\n          computeFields(prevEvent, prevprevEvent, operation);\n          computeFields(event,     prevEvent,     operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = prev = sweepLine.find(event);\n\n      if (prev && next) {\n\n        if (prev !== begin) prev = sweepLine.prev(prev);\n        else                prev = null;\n\n        next = sweepLine.next(next);\n        sweepLine.remove(event);\n\n        if (next && prev) {\n          possibleIntersection(prev.key, next.key, eventQueue);\n        }\n      }\n    }\n  }\n  return sortedEvents;\n}\n","import compareEvents from './compare_events';\nimport { DIFFERENCE } from './operation';\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<SweepEvent>}\n */\nfunction orderEvents(sortedEvents) {\n  let event, i, len, tmp;\n  const resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  let sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        tmp = resultEvents[i];\n        resultEvents[i] = resultEvents[i + 1];\n        resultEvents[i + 1] = tmp;\n        sorted = false;\n      }\n    }\n  }\n\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    event.pos = i;\n  }\n\n  // imagine, the right event is found in the beginning of the queue,\n  // when his left counterpart is not marked yet\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    if (!event.left) {\n      tmp = event.pos;\n      event.pos = event.otherEvent.pos;\n      event.otherEvent.pos = tmp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\n/**\n * @param  {Number} pos\n * @param  {Array.<SweepEvent>} resultEvents\n * @param  {Object>}    processed\n * @return {Number}\n */\nfunction nextPos(pos, resultEvents, processed, origIndex) {\n  let newPos = pos + 1;\n  const length = resultEvents.length;\n  if (newPos > length - 1) return pos - 1;\n  let p  = resultEvents[pos].point;\n  let p1 = resultEvents[newPos].point;\n\n\n  // while in range and not the current one by value\n  while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else   {\n      newPos++;\n    }\n    p1 = resultEvents[newPos].point;\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos] && newPos >= origIndex) {\n    newPos--;\n  }\n  return newPos;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<*>} polygons\n */\nexport default function connectEdges(sortedEvents, operation) {\n  let i, len;\n  const resultEvents = orderEvents(sortedEvents);\n\n  // \"false\"-filled array\n  const processed = {};\n  const result = [];\n  let event;\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (processed[i]) continue;\n    const contour = [[]];\n\n    if (!resultEvents[i].isExteriorRing) {\n      if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n        result.push(contour);\n      } else if (result.length === 0) {\n        result.push([[contour]]);\n      } else {\n        result[result.length - 1].push(contour[0]);\n      }\n    } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n      result[result.length - 1].push(contour[0]);\n    } else {\n      result.push(contour);\n    }\n\n    const ringId = result.length - 1;\n    let pos = i;\n\n    const initial = resultEvents[i].point;\n    contour[0].push(initial);\n\n    while (pos >= i) {\n      event = resultEvents[pos];\n      processed[pos] = true;\n\n      if (event.left) {\n        event.resultInOut = false;\n        event.contourId   = ringId;\n      } else {\n        event.otherEvent.resultInOut = true;\n        event.otherEvent.contourId   = ringId;\n      }\n\n      pos = event.pos;\n      processed[pos] = true;\n      contour[0].push(resultEvents[pos].point);\n      pos = nextPos(pos, resultEvents, processed, i);\n    }\n\n    pos = pos === -1 ? i : pos;\n\n    event = resultEvents[pos];\n    processed[pos] = processed[event.pos] = true;\n    event.otherEvent.resultInOut = true;\n    event.otherEvent.contourId   = ringId;\n  }\n\n  // Handle if the result is a polygon (eg not multipoly)\n  // Commented it again, let's see what do we mean by that\n  // if (result.length === 1) result = result[0];\n  return result;\n}\n","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","import Queue           from 'tinyqueue';\nimport SweepEvent      from './sweep_event';\nimport compareEvents   from './compare_events';\nimport { DIFFERENCE }  from './operation';\n\nconst max = Math.max;\nconst min = Math.min;\n\nlet contourId = 0;\n\n\nfunction processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n  let i, len, s1, s2, e1, e2;\n  for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n    s1 = contourOrHole[i];\n    s2 = contourOrHole[i + 1];\n    e1 = new SweepEvent(s1, false, undefined, isSubject);\n    e2 = new SweepEvent(s2, false, e1,        isSubject);\n    e1.otherEvent = e2;\n\n    if (s1[0] === s2[0] && s1[1] === s2[1]) {\n      continue; // skip collapsed edges, or it breaks\n    }\n\n    e1.contourId = e2.contourId = depth;\n    if (!isExteriorRing) {\n      e1.isExteriorRing = false;\n      e2.isExteriorRing = false;\n    }\n    if (compareEvents(e1, e2) > 0) {\n      e2.left = true;\n    } else {\n      e1.left = true;\n    }\n\n    const x = s1[0], y = s1[1];\n    bbox[0] = min(bbox[0], x);\n    bbox[1] = min(bbox[1], y);\n    bbox[2] = max(bbox[2], x);\n    bbox[3] = max(bbox[3], y);\n\n    // Pushing it so the queue is sorted from left to right,\n    // with object on the left having the highest priority.\n    Q.push(e1);\n    Q.push(e2);\n  }\n}\n\n\nexport default function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n  const eventQueue = new Queue(null, compareEvents);\n  let polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n  for (i = 0, ii = subject.length; i < ii; i++) {\n    polygonSet = subject[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n    }\n  }\n\n  for (i = 0, ii = clipping.length; i < ii; i++) {\n    polygonSet = clipping[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (operation === DIFFERENCE) isExteriorRing = false;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n    }\n  }\n\n  return eventQueue;\n}\n","import subdivideSegments from './subdivide_segments';\nimport connectEdges      from './connect_edges';\nimport fillQueue         from './fill_queue';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  UNION,\n  XOR\n}        from './operation';\n\nconst EMPTY = [];\n\n\nfunction trivialOperation(subject, clipping, operation) {\n  let result = null;\n  if (subject.length * clipping.length === 0) {\n    if        (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n  let result = null;\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if        (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) {\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nexport default function boolean(subject, clipping, operation) {\n  if (typeof subject[0][0][0] === 'number') {\n    subject = [subject];\n  }\n  if (typeof clipping[0][0][0] === 'number') {\n    clipping = [clipping];\n  }\n  let trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  const sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n  const cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  //console.time('fill queue');\n  const eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('fill queue');\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  //console.time('subdivide edges');\n  const sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('subdivide edges');\n\n  //console.time('connect vertices');\n  const result = connectEdges(sortedEvents, operation);\n  //console.timeEnd('connect vertices');\n  return result;\n}\n","import boolean from './src/';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  UNION,\n  XOR\n} from './src/operation';\n\nexport function union (subject, clipping) {\n  return boolean(subject, clipping, UNION);\n}\n\nexport function diff (subject, clipping) {\n  return boolean(subject, clipping, DIFFERENCE);\n}\n\nexport function xor (subject, clipping){\n  return boolean(subject, clipping, XOR);\n}\n\nexport function intersection (subject, clipping) {\n  return boolean(subject, clipping, INTERSECTION);\n}\n\n/**\n * @enum {Number}\n */\nexport const operations = { UNION, DIFFERENCE, INTERSECTION, XOR };\n"]},"metadata":{},"sourceType":"script"}